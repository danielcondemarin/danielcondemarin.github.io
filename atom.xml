<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>d&#39; dev panda ヽ(￣(ｴ)￣)ﾉ</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.devpanda.me/"/>
  <updated>2017-10-15T14:16:03.000Z</updated>
  <id>https://www.devpanda.me/</id>
  
  <author>
    <name>Daniel Conde</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AWS Route53 - DNS Whitelisting using Geolocation Routing</title>
    <link href="https://www.devpanda.me/2017/10/07/DNS-Blacklist-of-locations-countries-using-AWS-Route53/"/>
    <id>https://www.devpanda.me/2017/10/07/DNS-Blacklist-of-locations-countries-using-AWS-Route53/</id>
    <published>2017-10-07T13:41:25.000Z</published>
    <updated>2017-10-15T14:16:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>Assumptions:  Basic knowledge of AWS Route53</p>
<p>DNS can be a powerful tool, more so if you are using AWS Route53 as your provider.</p>
<p>In this post I will focus on how to use Route53’s <a href="http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-geo" target="_blank" rel="external">Geolocation routing</a> as a whitelist / blacklist of users originating from around the world.</p>
<p>So, let’s assume you only want users from the United Kingdom to access your website. This could be because all your customer base and operations are UK based, or maybe your application was DDoS’ed from various countries around the world, and you want to make sure any DNS query issued from this malicious Origin / IP is null routed.</p>
<p>First, let’s go to Route53 and create our first record set :</p>
<p><img src="https://res.cloudinary.com/danielcondemarin/image/upload/v1507497187/nullrouteset.png" alt="Null Route"></p>
<p>Please note this will be our default route, which will resolve to the IP Address <a href="https://en.wikipedia.org/wiki/Null_route" target="_blank" rel="external">0.0.0.0</a>. So, whenever a user attempts to reach your website domain (i.e. mywebsite.somedomain.co.uk) Route53 will resolve that DNS Query to <code>0.0.0.0</code>, then your machine will attempt to reach the website via the IP 0.0.0.0 which obviously doesn’t exist and will fail.</p>
<p>Let’s setup now the record for users originating from the UK and assume our webserver will be hosted on a server with IP <code>54.12.12.12</code> :</p>
<p><img src="https://res.cloudinary.com/danielcondemarin/image/upload/v1507497187/ukrouteset.png" alt="UK Route"></p>
<p>That should be it, the A records just created along with the domain NS records should be listed in your website Hosted Zone like this:</p>
<p><img src="https://res.cloudinary.com/danielcondemarin/image/upload/v1507497187/hostedzone.png" alt="Hosted Zone"></p>
<p>But how do we test this is working correctly? It should be easy be using <code>dig</code> via your terminal. Just grab one of the nameservers for your domain, listed above, and run the following command :</p>
<p><code>./bin/dig/dig @your-nameserver mywebsite.somedomain.co.uk +client=45.63.111.158/24</code></p>
<p>Caveat : You will need a <a href="https://www.gsic.uva.es/~jnisigl/dig-edns-client-subnet.html" target="_blank" rel="external">patched version</a> of <code>dig</code> in order to use the <code>+client</code> option. This option allows you to tell the nameserver the user ip address, which then it uses to return an IP Address from your records, based on the estimated geolocation of the IP Address you passed. This mainly works thanks to the <a href="https://tools.ietf.org/html/rfc7871" target="_blank" rel="external">client subnet in DNS queries</a>. </p>
<p><img src="https://res.cloudinary.com/danielcondemarin/image/upload/v1507500087/usdnsquery.png" alt="DNS Query with American IP Address"></p>
<p>I used the IP Address <code>45.63.111.158</code> which is from an American DNS Server I’ve found here <a href="https://public-dns.info/" target="_blank" rel="external">https://public-dns.info/</a>. Make sure you look again for a different IP since this might change.</p>
<p>Now, for the UK:</p>
<p><img src="https://res.cloudinary.com/danielcondemarin/image/upload/v1507500087/ukdnsquery.png" alt="DNS Query with UK IP Address"></p>
<p>That’s about it really, hope you found it interesting and give some real use to it.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Assumptions:  Basic knowledge of AWS Route53&lt;/p&gt;
&lt;p&gt;DNS can be a powerful tool, more so if you are using AWS Route53 as your provider.&lt;/p
    
    </summary>
    
    
      <category term="Route53" scheme="https://www.devpanda.me/tags/Route53/"/>
    
      <category term="Geolocation" scheme="https://www.devpanda.me/tags/Geolocation/"/>
    
      <category term="AWS" scheme="https://www.devpanda.me/tags/AWS/"/>
    
      <category term="Client Subnet" scheme="https://www.devpanda.me/tags/Client-Subnet/"/>
    
      <category term="DNS Blacklist" scheme="https://www.devpanda.me/tags/DNS-Blacklist/"/>
    
  </entry>
  
  <entry>
    <title>SSH Public Key authentication to your Edison</title>
    <link href="https://www.devpanda.me/2017/06/25/SSH-Public-Key-authentication-to-your-Edison/"/>
    <id>https://www.devpanda.me/2017/06/25/SSH-Public-Key-authentication-to-your-Edison/</id>
    <published>2017-06-25T08:43:38.000Z</published>
    <updated>2017-10-15T14:16:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>I believe the best developers are the laziest ones, those who <em>do more by doing less</em>. That includes not having to type in your password every time you want to login to your <strong>Intel Edison</strong>.</p>
<p>If you have worked with <strong>*nix</strong> systems, you might be familiar with SSH Public Key authentication. If you don’t know what that is, I strongly recommend having a read of this <a href="http://blakesmith.me/2010/02/08/understanding-public-key-private-key-concepts.html" target="_blank" rel="external">article</a>, it is by far one of the best explanations I’ve seen. </p>
<p>In a nutshell, we will be generating a private and a public key. Then we will copy ONLY the public key to the <strong>Edison</strong>. That way you will be able to login to the Edison automatically as long as you have the private key.</p>
<p>Let’s start, first open a terminal, then run the following commands:</p>
<ol>
<li><p>Generate private / public key pair via <a href="https://linux.die.net/man/1/ssh-keygen" target="_blank" rel="external">ssh-keygen</a>:</p>
<p> <code>ssh-keygen -t rsa</code></p>
<p> I named the key “<strong>edison_key</strong>“, but feel free to use your own name. When you’re prompted for the <strong>passphrase</strong> just press enter, to avoid creating one. It should all look like this:</p>
<p> <img src="/images/ssh-keygen.png" alt=""></p>
</li>
<li><p>Copy the public key (<strong>edison_key.pub</strong>) to your intel edison:</p>
<p> <code>cat /Users/daniel/.ssh/edison_key.pub | ssh root@192.168.0.10 &quot;mkdir -p ~/.ssh &amp;&amp; cat &gt;&gt;  ~/.ssh/authorized_keys&quot;</code></p>
<p> Make sure you replace <em>/Users/daniel/.ssh/edison_key.pub</em> with your own path. Also, I’m assuming the Edison is accessible via <strong>192.168.0.10</strong> with SSH enabled.</p>
</li>
<li><p>That’s it! Let’s connect now:</p>
<p><code>ssh root@192.168.0.10 -i /Users/daniel/.ssh/edison_key</code></p>
<p><img src="/images/login-via-pub.png" alt=""></p>
</li>
</ol>
<p>Tip: If you want to avoid specifying the private key <em>… -i /Users/daniel/.ssh/edison_key</em>, just use the default name when generating the key on step <em>1</em>, which is id_rsa.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I believe the best developers are the laziest ones, those who &lt;em&gt;do more by doing less&lt;/em&gt;. That includes not having to type in your pa
    
    </summary>
    
    
      <category term="Intel Edison" scheme="https://www.devpanda.me/tags/Intel-Edison/"/>
    
      <category term="SSH Public Key" scheme="https://www.devpanda.me/tags/SSH-Public-Key/"/>
    
  </entry>
  
</feed>
